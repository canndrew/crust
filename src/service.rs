use std::collections::{hash_map, HashMap};
use std::sync::{Arc, Mutex};
use std::io;
use std::io::Write;
use std::time::{Instant, Duration};

use service_discovery::ServiceDiscovery;
use sodiumoxide;
use sodiumoxide::crypto::box_;
use sodiumoxide::crypto::box_::{PublicKey, SecretKey};
use nat_traversal::{MappingContext, SimpleUdpHolePunchServer, SimpleTcpHolePunchServer};
use transport::{Listener, StreamInfo, PubRendezvousInfo, PrivRendezvousInfo};
use maidsafe_utilities::serialisation::{serialise, deserialise_from};
use w_result::{WOk, WErr};

use bootstrap;
use bootstrap::RaiiBootstrap;
use bootstrap_handler::BootstrapHandler;
use connection::Connection;
use static_contact_info::StaticContactInfo;
use error::Error;
use config::Config;
use peer_id::PeerId;
use crust_msg::CrustMsg;
use event::Event;
use peer_id;

/// Default beacon (service discovery) port.
pub const DEFAULT_BEACON_PORT: u16 = 5484;

/// The result of a `Service::prepare_contact_info` call.
#[derive(Debug)]
pub struct ConnectionInfoResult {
    /// The token that was passed to `prepare_connection_info`.
    pub result_token: u32,
    /// The new contact info (private half)
    pub priv_info: OurConnectionInfo,
    /// The new contact info (public half)
    pub pub_info: TheirConnectionInfo,
}

/// Contact info generated by a call to `Service::prepare_contact_info`.
#[derive(Debug)]
pub struct OurConnectionInfo {
    id: PeerId,
    info: PrivRendezvousInfo,
}

/// Contact info used to connect to another peer.
#[derive(Debug, RustcEncodable, RustcDecodable)]
pub struct TheirConnectionInfo {
    id: PeerId,
    info: PubRendezvousInfo,
}

/// A structure representing a connection manager.
///
/// This abstraction has a hidden dependency on a config file. Refer to [the docs for `FileHandler`]
/// (../file_handler/struct.FileHandler.html) and [an example config file flowchart]
/// (https://github.com/maidsafe/crust/blob/master/docs/vault_config_file_flowchart.pdf) for more
/// information.
pub struct Service {
    static_contact_info: Arc<Mutex<StaticContactInfo>>,
    event_tx: ::CrustEventSender,
    our_keys: (PublicKey, SecretKey),
    service_discovery: ServiceDiscovery<StaticContactInfo>,
    bootstrap: RaiiBootstrap,
    listener: Arc<Listener<Arc<MappingContext>>>,
    config: Config,
    connection_map: Arc<Mutex<HashMap<PeerId, Connection>>>,
    _udp_hole_punch_server: SimpleUdpHolePunchServer<Arc<MappingContext>>,
    _tcp_hole_punch_server: SimpleTcpHolePunchServer<Arc<MappingContext>>,
}

impl Service {
    /// Constructs a service. User needs to create an asynchronous channel, and provide
    /// the sender half to this method. Receiver will receive all `Event`s from this library.
    pub fn new(event_tx: ::CrustEventSender) -> Result<Service, Error> {
        Service::with_config(event_tx, try!(Config::read()))
    }
    
    /// Constructs a service with the given config. User needs to create an asynchronous channel,
    /// and provide the sender half to this method. Receiver will receive all `Event`s from this
    /// library.
    pub fn with_config(event_tx: ::CrustEventSender, config: Config) -> Result<Service, Error> {
        println!("Entered with_config");
        sodiumoxide::init();

        let our_keys = box_::gen_keypair();
        let our_public_key = our_keys.0.clone();

        // Form our initial contact info
        let static_contact_info = Arc::new(Mutex::new(StaticContactInfo {
            endpoints: Vec::new(),
            udp_mapper_servers: Vec::new(),
            tcp_mapper_servers: Vec::new(),
        }));

        let cloned_contact_info = static_contact_info.clone();
        let generator = move || {
            let ret = unwrap_result!(cloned_contact_info.lock()).clone();
            println!("Responding to beacon with: {:?}", ret);
            ret
        };
        println!("Creating service discovery");
        let service_discovery =
            try!(ServiceDiscovery::new_with_generator(config.service_discovery_port
                                                            .unwrap_or(DEFAULT_BEACON_PORT),
                                                      generator));

        let mapping_context = try!(MappingContext::new()
                                       .result_log()
                                       .or_else(|e| {
                                           Err(io::Error::new(io::ErrorKind::Other,
                                                              format!("Failed to create \
                                                                       MappingContext: {}",
                                                                      e)))
                                       }));
        // Form initial peer contact infos - these will also contain echo-service addrs.
        println!("Creating bootstrap handler");
        let bootstrap_cache =
            Arc::new(Mutex::new(try!(BootstrapHandler::new(&config.bootstrap_cache_name))));
        println!("Bootstrap cache name: {:?}", config.bootstrap_cache_name);
        let bootstrap_contacts = try!(bootstrap::get_known_contacts(&service_discovery,
                                                                    bootstrap_cache.clone(),
                                                                    &config));
        let connection_map = Arc::new(Mutex::new(HashMap::new()));

        mapping_context.add_simple_udp_servers(config.udp_mapper_servers.iter().cloned());
        mapping_context.add_simple_tcp_servers(config.tcp_mapper_servers.iter().cloned());
        let mapping_context = Arc::new(mapping_context);

        println!("Creating bootstrapper");
        let bootstrap = RaiiBootstrap::new(bootstrap_contacts,
                                           our_keys.0.clone(),
                                           event_tx.clone(),
                                           connection_map.clone(),
                                           bootstrap_cache.clone());

        let listener = Arc::new(Listener::new(mapping_context.clone()));

        let event_tx_cloned = event_tx.clone();
        let listener_cloned = listener.clone();
        let _ = thread!("Service listener", move || {
            let event_tx = event_tx_cloned;
            let listener = listener_cloned;
            loop {
                let mut stream = match listener.accept() {
                    None => break,
                    Some(Err(e)) => {
                        error!("Error accepting bootstrap connection: {}", e);
                        continue;
                    },
                    Some(Ok(stream)) => stream,
                };
                let event_tx = event_tx.clone();
                let _ = thread!("Service bootstrap accept", move || {
                    let their_key = match deserialise_from(&mut stream) {
                        Ok(CrustMsg::BootstrapRequest(k)) => k,
                        Ok(msg) => {
                            error!("Unexpected message from bootstrapping peer: {:?}", msg);
                            return;
                        },
                        Err(e) => {
                            error!("Error deserialising message from bootstrapping peer: {}", e);
                            return;
                        },
                    };
                    let their_id = peer_id::new_id(their_key);
                    let msg = CrustMsg::BootstrapResponse(our_public_key);
                    let msg = unwrap_result!(serialise(&msg));
                    match stream.write_all(&msg) {
                        Ok(()) => (),
                        Err(e) => {
                            error!("Error sending bootstrap response to peer {}: {}", their_id, e);
                            return;
                        },
                    };
                    if their_id == peer_id::new_id(our_public_key) {
                        error!("Bootstrapped to ourselves!");
                        return;
                    }
                    let _ = event_tx.send(Event::BootstrapAccept(their_id));
                });
            }
        });

        let deadline = Instant::now() + Duration::from_secs(2);
        let udp_hole_punch_server = try!(SimpleUdpHolePunchServer::new(mapping_context.clone(), deadline)
                                             .result_log().or_else(|err| {
                                                 let e: io::Error = From::from(err);
                                                 Err(e)
                                             }));
        let deadline = Instant::now() + Duration::from_secs(2);
        let tcp_hole_punch_server = try!(SimpleTcpHolePunchServer::new(mapping_context.clone(), deadline)
                                             .result_log()
                                             .or(Err(io::Error::new(io::ErrorKind::Other,
                                                                    "Failed to create TCP \
                                                                     hole punch server"))));

        {
            let mut static_contact_info = static_contact_info.lock().unwrap();
            static_contact_info.udp_mapper_servers.extend(udp_hole_punch_server.addresses());
            static_contact_info.tcp_mapper_servers.extend(tcp_hole_punch_server.addresses());
        }

        println!("Created service");
        let service = Service {
            static_contact_info: static_contact_info,
            our_keys: our_keys,
            event_tx: event_tx,
            service_discovery: service_discovery,
            bootstrap: bootstrap,
            listener: listener,
            config: config,
            connection_map: connection_map,
            _udp_hole_punch_server: udp_hole_punch_server,
            _tcp_hole_punch_server: tcp_hole_punch_server,
        };

        Ok(service)
    }

    /// Stop the bootstraping procedure
    pub fn stop_bootstrap(&mut self) {
        self.bootstrap.stop();
    }

    /// Starts accepting connections.
    pub fn start_listening(&mut self) -> io::Result<()> {
        let deadline = Instant::now() + Duration::from_secs(3);
        for res in self.listener.bind(&self.config.listen_endpoints[..], deadline) {
            match res {
                WOk(actual_endpoint, warnings) => {
                    info!("Listening on endpoint {}", actual_endpoint);
                    for w in warnings {
                        warn!("Bind warning: {}", w);
                    }
                },
                WErr(e) => {
                    error!("Bind error: {}", e);
                    return Err(io::Error::new(io::ErrorKind::Other, format!("Bind error: {}", e)));
                },
            }
        }
        let mut static_contact_info = unwrap_result!(self.static_contact_info.lock());
        static_contact_info.endpoints.extend(self.listener.external_endpoints());
        Ok(())
    }

    /// Starts listening for beacon broadcasts.
    pub fn start_service_discovery(&mut self) {
        if !self.service_discovery.set_listen_for_peers(true) {
            error!("Failed to start listening for peers.");
        }
    }

    /// Send the given `data` to the peer with the given `PeerId`.
    pub fn send(&self, id: PeerId, data: Vec<u8>) -> io::Result<()> {
        let ret = match unwrap_result!(self.connection_map.lock()).get_mut(&id) {
            None => {
                let msg = format!("No connection to peer {}", id);
                Err(io::Error::new(io::ErrorKind::Other, msg))
            },
            Some(mut connection) => {
                let msg = CrustMsg::Message(data);
                connection.send(msg)
            },
        };
        if let Err(ref e) = ret {
            info!("Lost connection to peer {}: {}", id, e);
            maybe_drop_connection(self.connection_map.clone(), id, self.event_tx.clone());
        };
        ret
    }

    /// Get information about our connection to a peer.
    pub fn stream_info(&self, id: &PeerId) -> Option<StreamInfo> {
        unwrap_result!(self.connection_map.lock())
            .get(&id)
            .map(|conn| conn.info())
    }

    /// Disconnect from the given peer and returns whether there was a connection at all.
    pub fn disconnect(&self, id: &PeerId) -> bool {
        debug!("dropping connection to peer {:?}", id);
        unwrap_result!(self.connection_map.lock()).remove(id).is_some()
    }

    /// Opens a connection to a remote peer. Both peers must call this method at the same time in
    /// order to create the connection. The connection info used is created by calling
    /// `prepare_connection_info` then swapping the `TheirConnectionInfo` with the remote peer.
    pub fn connect(&self,
                   our_connection_info: OurConnectionInfo,
                   their_connection_info: TheirConnectionInfo)
    {
        let their_id = their_connection_info.id;
        if their_id == self.id() {
            return;
        }

        if unwrap_result!(self.connection_map.lock()).contains_key(&their_id) {
            return;
        }

        let connection_map = self.connection_map.clone();
        let event_tx = self.event_tx.clone();
        let listener = self.listener.clone();
        let _ = thread!("Service::connect", move || {
            let deadline = Instant::now() + Duration::from_secs(10);
            let priv_info = our_connection_info.info;
            let pub_info  = their_connection_info.info;
            let res = listener.rendezvous_connect(priv_info, pub_info, deadline);
            match res {
                WOk(stream, ws) => {
                    let connection = Connection::from_stream(stream,
                                                             their_id,
                                                             connection_map.clone(),
                                                             event_tx.clone());
                    let mut cm = unwrap_result!(connection_map.lock());
                    match cm.entry(their_id) {
                        hash_map::Entry::Occupied(..) => (),
                        hash_map::Entry::Vacant(ve) => {
                            for w in ws {
                                info!("Warning raised from rendezvous connect: {}", w);
                            }
                            let _ = ve.insert(connection);
                            let _ = event_tx.send(Event::NewPeer(Ok(()), their_id));
                        },
                    }
                },
                WErr(e) => {
                    warn!("Error connecting to peer: {}", e);
                    let s = format!("Error performing rendezvous connect: {}", e);
                    let err = io::Error::new(io::ErrorKind::Other, s);
                    let _ = event_tx.send(Event::NewPeer(Err(err), their_id));
                },
            };
        });
    }

    /// Prepare connection info for use with `connect`
    pub fn prepare_connection_info(&mut self, result_token: u32) {
        let listener = self.listener.clone();
        let event_tx = self.event_tx.clone();
        let id = self.id();
        let _ = thread!("Service::prepare_connection_info", move || {
            let deadline = Instant::now() + Duration::from_secs(5);
            let (priv_info, pub_info, diags) = listener.gen_rendezvous_info(deadline);
            info!("prepare_connection_info diagnostics: {}", diags);
            let our_info = OurConnectionInfo {
                id: id,
                info: priv_info,
            };
            let their_info = TheirConnectionInfo {
                id: id,
                info: pub_info,
            };
            let result = ConnectionInfoResult {
                result_token: result_token,
                priv_info: our_info,
                pub_info: their_info,
            };
            let _ = event_tx.send(Event::ConnectionInfoPrepared(result));
        });
    }

    /// Returns our ID.
    pub fn id(&self) -> PeerId {
        peer_id::new_id(self.our_keys.0)
    }
}

impl Drop for Service {
    fn drop(&mut self) {
        self.listener.stop();

        // Disconnect from all peers when we drop the service
        let mut cm = unwrap_result!(self.connection_map.lock());
        cm.clear();
    }
}

/// Drops the connection for the given peer (if there is one) and sends the LostPeer event.
pub fn maybe_drop_connection(connection_map: Arc<Mutex<HashMap<PeerId, Connection>>>,
                             id: PeerId,
                             event_tx: ::CrustEventSender)
{
    let mut cm = unwrap_result!(connection_map.lock());
    if let Some(..) = cm.remove(&id) {
        let _ = event_tx.send(Event::LostPeer(id));
    }
}

#[cfg(test)]
mod test {
    use super::*;
    use config::Config;
    use event::Event;

    use std::time::Duration;
    use std::sync::atomic::{AtomicUsize, ATOMIC_USIZE_INIT, Ordering};
    use std::sync::{Arc, Barrier};
    use std::sync::mpsc;
    use std::sync::mpsc::Receiver;
    use std::thread;
    use std::thread::JoinHandle;
    use std::collections::{hash_map, HashMap};

    use crossbeam;
    use void::Void;
    use maidsafe_utilities::event_sender::{MaidSafeObserver, MaidSafeEventCategory};
    use maidsafe_utilities;

    fn get_event_sender()
        -> (::CrustEventSender,
            Receiver<MaidSafeEventCategory>,
            Receiver<Event>)
    {
        let (category_tx, category_rx) = mpsc::channel();
        let event_category = MaidSafeEventCategory::Crust;
        let (event_tx, event_rx) = mpsc::channel();

        (MaidSafeObserver::new(event_tx, event_category, category_tx),
         category_rx,
         event_rx)
    }

    fn timebomb<R, F>(dur: Duration, f: F) -> R
        where R: Send,
              F: Send + FnOnce() -> R
    {
        crossbeam::scope(|scope| {
            let thread_handle = thread::current();
            let (done_tx, done_rx) = mpsc::channel::<Void>();
            let jh = scope.spawn(move || {
                let ret = f();
                drop(done_tx);
                thread_handle.unpark();
                ret
            });
            thread::park_timeout(dur);
            match done_rx.try_recv() {
                Ok(x) => match x {},
                Err(mpsc::TryRecvError::Empty) => panic!("Timed out!"),
                Err(mpsc::TryRecvError::Disconnected) => jh.join(),
            }
        })
    }

    // Generate unique name for the bootstrap cache.
    fn gen_bootstrap_cache_name() -> String {
        static COUNTER: AtomicUsize = ATOMIC_USIZE_INIT;
        format!("test{}.bootstrap.cache",
                COUNTER.fetch_add(1, Ordering::Relaxed))
    }

    fn gen_beacon_port() -> u16 {
        const BASE: u16 = 40000;
        static COUNTER: AtomicUsize = ATOMIC_USIZE_INIT;

        BASE + COUNTER.fetch_add(1, Ordering::Relaxed) as u16
    }

    fn gen_config() -> Config {
        let mut config = Config::default();
        config.bootstrap_cache_name = Some(gen_bootstrap_cache_name());
        config
    }

    fn gen_config_with_beacon(port: u16) -> Config {
        let mut config = gen_config();
        config.service_discovery_port = Some(port);
        config
    }

    fn prepare_connection_info(service: &mut Service, event_rx: &Receiver<Event>) -> (OurConnectionInfo, TheirConnectionInfo) {
        static TOKEN_COUNTER: AtomicUsize = ATOMIC_USIZE_INIT;
        let token = TOKEN_COUNTER.fetch_add(1, Ordering::Relaxed) as u32;

        service.prepare_connection_info(token);

        match unwrap_result!(event_rx.recv()) {
            Event::ConnectionInfoPrepared(cir) => {
                assert_eq!(cir.result_token, token);
                (cir.priv_info, cir.pub_info)
            }
            event => panic!("Received unexpected event: {:?}", event),
        }
    }

    #[test]
    fn start_stop_service() {
        let config = gen_config();
        let (event_sender, _category_rx, _) = get_event_sender();
        let _service = unwrap_result!(Service::with_config(event_sender, config));
    }

    fn bootstrap_connection_two_services() {
        let (event_sender_0, _category_rx_0, event_rx_0) = get_event_sender();
        let (event_sender_1, _category_rx_1, event_rx_1) = get_event_sender();

        let beacon_port = gen_beacon_port();
        let config_0 = gen_config_with_beacon(beacon_port);
        let config_1 = gen_config_with_beacon(beacon_port);

        let mut service_0 = unwrap_result!(Service::with_config(event_sender_0, config_0));
        unwrap_result!(service_0.start_listening());

        // let service_0 finish bootstrap - since it is the zero state, it should not find any peer
        // to bootstrap
        {
            let event_rxd = unwrap_result!(event_rx_0.recv());
            match event_rxd {
                Event::BootstrapFinished => (),
                _ => panic!("Received unexpected event: {:?}", event_rxd),
            }
        }
        service_0.start_service_discovery();

        let mut service_1 = unwrap_result!(Service::with_config(event_sender_1, config_1));
        unwrap_result!(service_1.start_listening());

        // let service_1 finish bootstrap - it should bootstrap off service_0
        let id_0 = {
            let event_rxd = unwrap_result!(event_rx_1.recv());
            match event_rxd {
                Event::BootstrapConnect(their_id) => their_id,
                _ => panic!("Received unexpected event: {:?}", event_rxd),
            }
        };

        // now service_1 should get BootstrapFinished
        {
            let event_rxd = unwrap_result!(event_rx_1.recv());
            match event_rxd {
                Event::BootstrapFinished => (),
                _ => panic!("Received unexpected event: {:?}", event_rxd),
            }
        }

        // service_0 should have received service_1's bootstrap connection by now
        let id_1 = match unwrap_result!(event_rx_0.recv()) {
            Event::BootstrapAccept(their_id) => their_id,
            _ => panic!("0 Should have got a new connection from 1."),
        };

        // TODO: Evaluate whether these are still needed.
        // if use_tcp {
        // assert_eq!(*connection_0_to_1.get_protocol(), Protocol::Tcp);
        // assert_eq!(*connection_1_to_0.get_protocol(), Protocol::Tcp);
        // } else {
        // assert_eq!(*connection_0_to_1.get_protocol(), Protocol::Utp);
        // assert_eq!(*connection_1_to_0.get_protocol(), Protocol::Utp);
        // }


        assert!(id_0 != id_1);

        // send data from 0 to 1
        {
            let data_txd = vec![0, 1, 255, 254, 222, 1];
            unwrap_result!(service_0.send(id_1, data_txd.clone()));

            // 1 should rx data
            let (data_rxd, peer_id) = {
                let event_rxd = unwrap_result!(event_rx_1.recv());
                match event_rxd {
                    Event::NewMessage(their_id, msg) => (msg, their_id),
                    _ => panic!("Received unexpected event: {:?}", event_rxd),
                }
            };

            assert_eq!(data_rxd, data_txd);
            assert_eq!(peer_id, id_0);
        }

        // send data from 1 to 0
        {
            let data_txd = vec![10, 11, 155, 214, 202];
            unwrap_result!(service_1.send(id_0, data_txd.clone()));

            // 0 should rx data
            let (data_rxd, peer_id) = {
                let event_rxd = unwrap_result!(event_rx_0.recv());
                match event_rxd {
                    Event::NewMessage(their_id, msg) => (msg, their_id),
                    _ => panic!("Received unexpected event: {:?}", event_rxd),
                }
            };

            assert_eq!(data_rxd, data_txd);
            assert_eq!(peer_id, id_1);
        }

        assert!(service_0.disconnect(&id_1));

        match unwrap_result!(event_rx_1.recv()) {
            Event::LostPeer(id) => assert_eq!(id, id_0),
            e => panic!("Received unexpected event: {:?}", e),
        }

        // Drop services and make sure the event channels close
        drop(service_0);
        let (done_tx, done_rx) = mpsc::channel();
        let thread_handle = thread::current();
        let tj = thread!("Drain event channel messages", move || {
            match event_rx_0.recv() {
                Ok(e) => panic!("Received unexpected event when shutting down: {:?}", e),
                Err(mpsc::RecvError) => (),
            };
            unwrap_result!(done_tx.send(()));
            thread_handle.unpark();
        });
        thread::park_timeout(Duration::from_secs(60));
        unwrap_result!(done_rx.try_recv());
        unwrap_result!(tj.join());

        drop(service_1);
        let (done_tx, done_rx) = mpsc::channel();
        let thread_handle = thread::current();
        let tj = thread!("Drain event channel messages", move || {
            match event_rx_1.recv() {
                Ok(e) => panic!("Received unexpected event when shutting down: {:?}", e),
                Err(mpsc::RecvError) => (),
            };
            unwrap_result!(done_tx.send(()));
            thread_handle.unpark();
        });
        thread::park_timeout(Duration::from_secs(5));
        unwrap_result!(done_rx.try_recv());
        unwrap_result!(tj.join());
    }

    #[test]
    fn bootstrap_connection_tcp_two_services() {
        let _ = maidsafe_utilities::log::init(true);
        bootstrap_connection_two_services();
    }

    /*
    #[test]
    fn bootstrap_connection_udp_two_services() {
        bootstrap_connection_two_services(Protocol::Udp);
    }

    #[test]
    fn bootstrap_connection_tcp_and_udp_two_services() {
        bootstrap_connection_two_services(Protocol::Both);
    }
    */

    fn peer_to_peer_connection_two_services(listen_0: bool, listen_1: bool) {
        let (event_sender_0, _category_rx_0, event_rx_0) = get_event_sender();
        let (event_sender_1, _category_rx_1, event_rx_1) = get_event_sender();

        let config = gen_config();
        let mut service_0 = unwrap_result!(Service::with_config(event_sender_0, config));
        if listen_0 {
            unwrap_result!(service_0.start_listening());
        }

        // let service_0 finish bootstrap - since it is the zero state, it should not find any peer
        // to bootstrap
        match unwrap_result!(event_rx_0.recv()) {
            Event::BootstrapFinished => (),
            event => panic!("Received unexpected event: {:?}", event),
        }

        let config = gen_config();
        let mut service_1 = unwrap_result!(Service::with_config(event_sender_1, config));
        if listen_1 {
            unwrap_result!(service_1.start_listening());
        }

        // let service_0 finish bootstrap - since it is the zero state, it should not find any peer
        // to bootstrap
        match unwrap_result!(event_rx_1.recv()) {
            Event::BootstrapFinished => (),
            event => panic!("Received unexpected event: {:?}", event),
        }

        let (our_ci_0, their_ci_0) = prepare_connection_info(&mut service_0, &event_rx_0);

        let (our_ci_1, their_ci_1) = prepare_connection_info(&mut service_1, &event_rx_1);

        service_0.connect(our_ci_0, their_ci_1);
        service_1.connect(our_ci_1, their_ci_0);

        let id_1 = match unwrap_result!(event_rx_0.recv()) {
            Event::NewPeer(Ok(()), their_id) => their_id,
            m => panic!("0 Should have connected to 1. Got message {:?}", m),
        };

        let id_0 = match unwrap_result!(event_rx_1.recv()) {
            Event::NewPeer(Ok(()), their_id) => their_id,
            m => panic!("1 Should have connected to 0. Got message {:?}", m),
        };

        // send data from 0 to 1
        {
            let data_txd = vec![0, 1, 255, 254, 222, 1];
            unwrap_result!(service_0.send(id_1, data_txd.clone()));

            // 1 should rx data
            let (data_rxd, peer_id) = {
                let event_rxd = unwrap_result!(event_rx_1.recv());
                match event_rxd {
                    Event::NewMessage(their_id, msg) => (msg, their_id),
                    _ => panic!("Received unexpected event: {:?}", event_rxd),
                }
            };

            assert_eq!(data_rxd, data_txd);
            assert_eq!(peer_id, id_0);
        }

        // send data from 1 to 0
        {
            let data_txd = vec![10, 11, 155, 214, 202];
            unwrap_result!(service_1.send(id_0, data_txd.clone()));

            // 0 should rx data
            let (data_rxd, peer_id) = {
                let event_rxd = unwrap_result!(event_rx_0.recv());
                match event_rxd {
                    Event::NewMessage(their_id, msg) => (msg, their_id),
                    _ => panic!("Received unexpected event: {:?}", event_rxd),
                }
            };

            assert_eq!(data_rxd, data_txd);
            assert_eq!(peer_id, id_1);
        }

        // Drop services and make sure the event channels close
        drop(service_0);
        match event_rx_1.recv() {
            Ok(Event::LostPeer(id)) => assert_eq!(id_0, id),
            event => panic!("Received unexpected event: {:?}", event),
        }
    }

    #[test]
    fn direct_connection_tcp_two_services() {
        peer_to_peer_connection_two_services(true, true)
    }

    /*
    #[test]
    fn direct_connection_udp_two_services() {
        peer_to_peer_connection_two_services(Protocol::Udp, true, true)
    }
    */

    #[test]
    fn semi_direct_connection_tcp_two_services() {
        peer_to_peer_connection_two_services(true, false)
    }

    /*
    #[test]
    fn semi_direct_connection_udp_two_services() {
        peer_to_peer_connection_two_services(Protocol::Udp, true, false)
    }
    */

    #[test]
    fn rendezvous_connection_tcp_two_services() {
        peer_to_peer_connection_two_services(false, false);
    }

    /*
    #[test]
    fn rendezvous_connection_udp_two_services() {
        peer_to_peer_connection_two_services(Protocol::Udp, false, false);
    }
    */

    // TODO: change this to allow arbitrary number of nodes.
    fn rendezvous_connection_three_services() {
        const NUM_SERVICES: usize = 3;
        const MSG_SIZE: usize = 1024;
        const NUM_MSGS: usize = 257;

        struct TestNode {
            event_rx: Receiver<Event>,
            _category_rx: Receiver<MaidSafeEventCategory>,
            service: Service,
            connection_id_rx: Receiver<TheirConnectionInfo>,
            our_cis: Vec<OurConnectionInfo>,
            our_index: usize,
        }

        impl TestNode {
            fn new(index: usize)
                   -> (TestNode, mpsc::Sender<TheirConnectionInfo>) {
                let (event_sender, category_rx, event_rx) = get_event_sender();
                let config = unwrap_result!(Config::read());
                let service = unwrap_result!(Service::with_config(event_sender, config));
                match unwrap_result!(event_rx.recv()) {
                    Event::BootstrapFinished => (),
                    m => panic!("Expected BootstrapFinished, got:{:?}", m),
                };
                let (ci_tx, ci_rx) = mpsc::channel();
                (TestNode {
                    event_rx: event_rx,
                    _category_rx: category_rx,
                    service: service,
                    connection_id_rx: ci_rx,
                    our_cis: Vec::new(),
                    our_index: index,
                },
                 ci_tx)
            }

            fn make_connection_infos(&mut self, ci_txs: &[mpsc::Sender<TheirConnectionInfo>]) {
                for (i, ci_tx) in ci_txs.iter().enumerate() {
                    if i == self.our_index {
                        continue;
                    }

                    let (our_ci, their_ci) = prepare_connection_info(&mut self.service, &self.event_rx);
                    let _ = ci_tx.send(their_ci);
                    self.our_cis.push(our_ci);
                }
            }

            fn run(self, send_barrier: Arc<Barrier>, drop_barrier: Arc<Barrier>) -> JoinHandle<()> {
                thread!("run!", move || {
                    for (our_ci, their_ci) in self.our_cis
                                                  .into_iter()
                                                  .zip(self.connection_id_rx.into_iter()) {
                        self.service.connect(our_ci, their_ci);
                    }
                    let mut their_ids = HashMap::new();
                    for _ in 0..(NUM_SERVICES - 1) {
                        let their_id = match unwrap_result!(self.event_rx.recv()) {
                            Event::NewPeer(Ok(()), their_id) => their_id,
                            m => panic!("Expected NewPeer message. Got message {:?}", m),
                        };
                        match their_ids.insert(their_id, 0u32) {
                            Some(_) => panic!("Received two NewPeer events for same peer!"),
                            None => (),
                        };
                    }

                    // Wait until all nodes have connected to each other before we start
                    // exchanging messages.
                    let _ = send_barrier.wait();

                    for their_id in their_ids.keys() {
                        for n in 0..NUM_MSGS {
                            let mut msg = Vec::with_capacity(MSG_SIZE);
                            for _ in 0..MSG_SIZE {
                                msg.push(n as u8);
                            }
                            let _ = self.service.send(*their_id, msg);
                        }
                    }

                    for _ in 0..((NUM_SERVICES - 1) * NUM_MSGS) {
                        match unwrap_result!(self.event_rx.recv()) {
                            Event::NewMessage(their_id, msg) => {
                                let n = msg[0];
                                assert_eq!(msg.len(), MSG_SIZE);
                                for m in msg {
                                    assert_eq!(n, m);
                                }
                                match their_ids.entry(their_id.clone()) {
                                    hash_map::Entry::Occupied(mut oe) => {
                                        let next_msg = oe.get_mut();
                                        assert_eq!(*next_msg as u8, n);
                                        *next_msg += 1;
                                    }
                                    hash_map::Entry::Vacant(_) => panic!("impossible!"),
                                }
                            }
                            m => panic!("Unexpected msg receiving NewMessage: {:?}", m),
                        }
                    }

                    // Wait until all nodes have finished exchanging messages before we start
                    // disconnecting.
                    let _ = drop_barrier.wait();

                    drop(self.service);
                    match self.event_rx.recv() {
                        Ok(m) => {
                            match m {
                                Event::LostPeer(..) => (),
                                _ => panic!("Unexpected message when shutting down: {:?}", m),
                            }
                        }
                        Err(mpsc::RecvError) => (),
                    }
                })
            }
        }

        let mut test_nodes = Vec::new();
        let mut ci_txs = Vec::new();
        for i in 0..NUM_SERVICES {
            let (test_node, ci_tx) = TestNode::new(i);
            test_nodes.push(test_node);
            ci_txs.push(ci_tx);
        }

        for test_node in &mut test_nodes {
            test_node.make_connection_infos(&ci_txs);
        }

        let send_barrier = Arc::new(Barrier::new(NUM_SERVICES));
        let drop_barrier = Arc::new(Barrier::new(NUM_SERVICES));
        let mut threads = Vec::new();
        for test_node in test_nodes {
            let send_barrier = send_barrier.clone();
            let drop_barrier = drop_barrier.clone();
            threads.push(test_node.run(send_barrier, drop_barrier));
        }

        // Wait one hundred millisecond per message
        // TODO(canndrew): drop this limit
        let timeout_ms = 100 * (NUM_MSGS * (NUM_SERVICES * (NUM_SERVICES - 1)) / 2) as u64;
        timebomb(Duration::from_millis(timeout_ms), move || {
            for thread in threads {
                unwrap_result!(thread.join());
            }
        });
    }

    /*
    #[test]
    fn rendezvous_connection_udp_three_services() {
        rendezvous_connection_three_services(Protocol::Udp);
    }
    */

    #[test]
    fn rendezvous_connection_tcp_three_service() {
        rendezvous_connection_three_services();
    }

    #[test]
    fn drop_disconnects() {
        let beacon_port = gen_beacon_port();

        let config_0 = gen_config_with_beacon(beacon_port);
        let config_1 = gen_config_with_beacon(beacon_port);

        let (event_sender_0, _category_rx_0, event_rx_0) = get_event_sender();
        let (event_sender_1, _category_rx_1, event_rx_1) = get_event_sender();

        let mut service_0 = unwrap_result!(Service::with_config(event_sender_0, config_0));
        unwrap_result!(service_0.start_listening());

        // Let service_0 finish bootstrap - it should not find any peer.
        match unwrap_result!(event_rx_0.recv()) {
            Event::BootstrapFinished => (),
            event_rxd => panic!("Received unexpected event: {:?}", event_rxd),
        }
        service_0.start_service_discovery();

        let mut service_1 = unwrap_result!(Service::with_config(event_sender_1, config_1));
        unwrap_result!(service_1.start_listening());

        // Let service_1 finish bootstrap - it should bootstrap off service_0.
        let id_0 = match unwrap_result!(event_rx_1.recv()) {
            Event::BootstrapConnect(their_id) => their_id,
            event => panic!("Received unexpected event: {:?}", event),
        };

        // Now service_1 should get BootstrapFinished.
        match unwrap_result!(event_rx_1.recv()) {
            Event::BootstrapFinished => (),
            event => panic!("Received unexpected event: {:?}", event),
        }

        // service_0 should have received service_1's bootstrap connection by now.
        let _ = match unwrap_result!(event_rx_0.recv()) {
            Event::BootstrapAccept(their_id) => their_id,
            _ => panic!("0 Should have got a new connection from 1."),
        };

        // Dropping service_0 should make service_1 receive a LostPeer event.
        drop(service_0);
        match unwrap_result!(event_rx_1.recv()) {
            Event::LostPeer(id) => assert_eq!(id, id_0),
            event => panic!("Received unexpected event: {:?}", event),
        }
    }

    /*
    #[test]
    fn skip_invalid_bootstrap_contacts() {
        let mut contact_info = StaticContactInfo::default();

        contact_info.endpoints = vec!["tcp://127.0.0.1:1234".parse()];

        let mut config = Config::default();
        config.hard_coded_contacts = vec![contact_info];

        let (event_sender, _category_rx, event_rx) = get_event_sender();
        let _service = unwrap_result!(Service::with_config(event_sender, config));

        timebomb(Duration::from_secs(70), move || {
            match unwrap_result!(event_rx.recv()) {
                Event::BootstrapFinished => (),
                event => panic!("Received unexpected event: {:?}", event),
            }
        });
    }
    */

    #[test]
    fn new_peer_is_not_raised_if_only_one_party_calls_connect() {
         let config_0 = gen_config();
        let config_1 = gen_config();

        let (event_sender_0, _category_rx_0, event_rx_0) = get_event_sender();
        let (event_sender_1, _category_rx_1, event_rx_1) = get_event_sender();

        let mut service_0 = unwrap_result!(Service::with_config(event_sender_0, config_0));
        match unwrap_result!(event_rx_0.recv()) {
            Event::BootstrapFinished => (),
            event => panic!("Received unexpected event: {:?}", event),
        }

        unwrap_result!(service_0.start_listening());

        let mut service_1 = unwrap_result!(Service::with_config(event_sender_1, config_1));
        match unwrap_result!(event_rx_1.recv()) {
            Event::BootstrapFinished => (),
            event => panic!("Received unexpected event: {:?}", event),
        }

        unwrap_result!(service_1.start_listening());

        let (our_ci_0, _their_ci_0) = prepare_connection_info(&mut service_0, &event_rx_0);
        let (_our_ci_1, their_ci_1) = prepare_connection_info(&mut service_1, &event_rx_1);

        service_0.connect(our_ci_0, their_ci_1);

        thread::sleep(Duration::from_millis(1000));

        match event_rx_0.try_recv() {
            Ok(Event::NewPeer(Ok(()), _)) => panic!("Unexpected NewPeer event"),
            _ => (),
        }

        match event_rx_1.try_recv() {
            Ok(Event::NewPeer(Ok(()), _)) => panic!("Unexpected NewPeer event"),
            _ => (),
        }
    }
}
